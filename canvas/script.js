const canvas = document.querySelector('#draw'); // находим наш элемент
const ctx = canvas.getContext('2d'); // задаем контекст - Этот метод генерирует контекст рисования, который будет связан с указанным холстом. Мы будем использовать ссылку на получившийся контекст рисования, работая с остальными возможностями API холста.
canvas.width = window.innerWidth; // берет ширину и высоту окна
canvas.height = window.innerHeight;
ctx.strokeStyle = '#BADA55'; // задаёт цвет или стиль, используемый при выполнении обводки фигур. По умолчанию установлено значение #000 (чёрный цвет).
ctx.lineJoin = 'round'; // определяет форму вершин в которых линии сходятся. Длина линий должна быть ненулевой.
ctx.lineCap = 'round'; // устанавливает/возвращает стиль концов нарисованной линии.
ctx.lineWidth = 20; // ширина нашей линии

let isDrawing = false; // рисуем ли мы в данный момент - когда будем нажимать и рисовать - будет тру, как только мышка отпускается  - фолс
// координаты, где мы будем заканчивать рисунок
let lastX = 0;
let lastY = 0;
let hue = 0;
let direction = true;
// контекст помогает задавать все условия, чтобы рисовать
function draw(e){
  if(!isDrawing) {
    return ; // stop the funtion from running when they are not moused down
  }
    console.log(e);
  ctx.strokeStyle = `hsl(${hue}, 100%,50% )`;
  ctx.beginPath(); // запускает новый путь, опуская список подпутей. Вызовите этот метод, когда хотите создать новый путь.
  // start from
  ctx.moveTo(lastX, lastY); // перемещает начальную точку нового фрагмента контура в координаты (x, y).
  // go to
  ctx.lineTo(e.offsetX, e.offsetY); // добавляет линию к текущему под пути с конечной точкой с координатами (x, y) - точки, на которые мы нажимаем мыжкой и ведем ее. Сам метод ничего не рисует, он лишь добавляет подпуть к текущему пути
  ctx.stroke(); // обводит текущий или данный контур цветом strokeStyle
  [lastX ,lastY] = [e.offsetX, e.offsetY] // каждый раз начальная позиция обновляется, чтобы становится текущей - чтобы была одна линия, а не несколько из одной точки
  hue++; // каждый раз прибавляем по градусу, изменяя оттенок
  if (hue > 360) {
    hue = 0;
  }
  if(ctx.lineWidth >= 100 || ctx.lineWidth <= 1){
    direction = !direction; // меняем направление и начинаем уменьшать линию или увеличивать в зависимости от условия
  }
  if (direction){
    ctx.lineWidth++;
  } else {
    ctx.lineWidth--;
  }
 
}
// будет рисовать только в момент, когда мышка будет нажата и ей будут водить по экрану, как только отпустят, функция остановится
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mousedown', (e) => {
  isDrawing = true;
  [lastX ,lastY] = [e.offsetX, e.offsetY]; // каждый раз обновляем начальную точку - ей становится та точка, на которую нажимает мышь каждый раз в момент начала действия
}); // Событие mousedown срабатывает, когда кнопка указывающего устройства (к примеру, мыши) нажата над элементом.
canvas.addEventListener('mouseup', () => isDrawing = false); // Событие mouseup возникает на Element, когда кнопка на аппаратном манипуляторе курсора (на мыши или трекпаде) отпущена, в то время как указатель находится на элементе. Событие mouseup является противоположным mousedown событию.
canvas.addEventListener('mouseout', () => isDrawing = false); //Событие mouseout запускается в элементе, когда указывающее устройство (обычно мышь) используется для перемещения курсора так, чтобы он больше не содержался в элементе или одном из его дочерних элементов. mouseout также доставляется в элемент, если курсор входит в дочерний элемент, поскольку дочерний элемент закрывает видимую область элемента.